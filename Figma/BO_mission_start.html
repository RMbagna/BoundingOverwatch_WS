<!-- Main container for the Mission Start Page -->
<div style="width: 100%; height: 100%; position: relative; background: white; overflow: hidden">
    
    <!-- Header section containing navigation tabs and quit button -->
    <div style="width: 1440px; height: 94px; padding-left: 100px; padding-right: 100px; left: 0px; top: 0px; position: absolute; justify-content: space-between; align-items: center; display: inline-flex">
        
        <!-- Navigation tabs -->
        <div style="justify-content: flex-start; align-items: flex-start; gap: 52px; display: flex">
            <!-- Home tab -->
            <a href="BO_home_page.html" data-layer="Tab menu" data-status="Off" class="TabMenu" style="padding-bottom: 4px; justify-content: flex-start; align-items: flex-start; gap: 10px; display: flex">
                <div data-layer="Home" class="Home" style="color: #333333; font-size: 20px; font-family: Sarabun; font-weight: 400; line-height: 32px; word-wrap: break-word">Home</div>
            </a>
            <!-- Background tab -->
            <a href="BO_background_page.html" data-layer="Tab menu" data-status="Off" class="TabMenu" style="padding-bottom: 4px; justify-content: flex-start; align-items: flex-start; gap: 10px; display: flex">
                <div data-layer="Background" class="Background" style="color: #333333; font-size: 20px; font-family: Sarabun; font-weight: 400; line-height: 32px; word-wrap: break-word">Background</div>
            </a>
            <!-- Tracker link -->
            <div data-status="Off" style="padding-bottom: 4px; justify-content: flex-start; align-items: flex-start; gap: 10px; display: flex">
                <div id="tracker" style="color: #333333; font-size: 20px; font-family: Sarabun; font-weight: 400; line-height: 32px; word-wrap: break-word">Tracker: 1/30</div>
            </div>
            <!-- Safety Score tab -->
            <!-- <div data-status="Off" style="padding-bottom: 4px; justify-content: flex-start; align-items: flex-start; gap: 10px; display: flex">
                <div style="color: #333333; font-size: 20px; font-family: Sarabun; font-weight: 400; line-height: 32px; word-wrap: break-word">Safety Score:</div>
            </div> -->
            <!-- Risk Score tab -->
            <div data-status="Off" style="padding-bottom: 4px; justify-content: flex-start; align-items: flex-start; gap: 10px; display: flex">
                <div style="color: #333333; font-size: 20px; font-family: Sarabun; font-weight: 400; line-height: 32px; word-wrap: break-word">Risk Score:</div>
            </div>
        </div>
        
        <!-- Quit button -->
        <a href="BO_end_page.html" data-layer="Quit-Button" class="QuitButton" style="width: 129px; height: 54px; padding-left: 24px; padding-right: 24px; background: rgba(246.50, 31.84, 31.84, 0.77); border-radius: 32px; justify-content: center; align-items: center; gap: 8px; display: flex">
            <div data-layer="Quit" class="Quit" style="flex-direction: column; justify-content: center; align-items: center; display: inline-flex">
            <div data-layer="Text Detail" class="TextDetail" style="justify-content: flex-start; align-items: flex-start; gap: 8px; display: inline-flex">
                <div data-layer="Primary Button" class="PrimaryButton" style="color: #FAEEEE; font-size: 16px; font-family: Sarabun; font-weight: 700; line-height: 24px; word-wrap: break-word">Quit</div>
            </div>
            </div>
        </a>
    </div>
    
    <!-- Body section containing interactive and static sections -->
    <div style="width: 1440px; height: 1024px; left: 0px; top: 94px; position: absolute">
        
        <!-- Interactive section with path selection and buttons -->
        <div style="width: 608px; height: 1024px; left: 732px; top: 0px; position: absolute">
            <div style="width: 1036px; height: 1024px; left: -327px; top: 0px; position: absolute; background: rgba(51, 50, 31, 0.49)"></div>
            <div style="width: 555px; left: 84px; top: 338px; position: absolute; color: #FFFBFB; font-size: 28px; font-family: Sarabun; font-weight: 700; line-height: 45px; word-wrap: break-word">Which of the following robot path do you prefer to follow?</div>
            
        <!-- Robot selection options -->
              <style>
                input[type="radio"] {
                  width: 24px;
                  height: 24px;
                  appearance: none;
                  outline: 1.50px #1B3360 solid;
                  border-radius: 50%;
                  position: relative;
                  cursor: pointer;
                }

                input[type="radio"]:checked {
                  background-color: #1B3360; /* Solid color when checked */
                  border: none; /* Remove the border when checked */
                }

              </style>
              <div style="left: 84px; top: 643px; position: absolute;">
                <label style="display: flex; justify-content: flex-start; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="radio" name="robot" value="robot3"/>
                  <div style="color: white; font-size: 24px; font-family: Sarabun; font-weight: 400; line-height: 24px; word-wrap: break-word">Robot 3</div>
                </label>
              </div>
              <div style="left: 84px; top: 559px; position: absolute;">
                <label style="display: flex; justify-content: flex-start; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="radio" name="robot" value="robot2"/>
                  <div style="color: white; font-size: 24px; font-family: Sarabun; font-weight: 400; line-height: 24px; word-wrap: break-word">Robot 2</div>
                </label>
              </div>
              <div style="left: 84px; top: 488px; position: absolute;">
                <label style="display: flex; justify-content: flex-start; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="radio" name="robot" value="robot1"/>
                  <div style="color: white; font-size: 24px; font-family: Sarabun; font-weight: 400; line-height: 24px; word-wrap: break-word">Robot 1</div>
                </label>
              </div>
            
            <!-- Next button -->
            <a href="BO_mission_start.html" style="text-decoration: none;" class="next-button">
              <div style="width: 181px; height: 54px; padding-left: 24px; padding-right: 24px; left: 361px; top: 754px; position: absolute; background: #1B6048; border-radius: 32px; flex-direction: column; justify-content: center; align-items: center; display: inline-flex">
                <div style="flex-direction: column; justify-content: center; align-items: center; display: flex">
                  <div style="justify-content: flex-start; align-items: flex-start; gap: 8px; display: inline-flex">
                    <div style="color: white; font-size: 16px; font-family: Sarabun; font-weight: 700; line-height: 24px; word-wrap: break-word">Next</div>
                  </div>
                </div>
              </div>
            </a>
            <!-- Switch button -->
        <a href="BO_home_page.html" style="text-decoration: none;" id="switchButton">
            <div style="width: 181px; height: 54px; padding-left: 24px; padding-right: 24px; left: 100px; top: 754px; position: absolute; background: #1B3360; border-radius: 32px; flex-direction: column; justify-content: center; align-items: center; display: inline-flex">
              <div style="flex-direction: column; justify-content: center; align-items: center; display: flex">
          <div style="justify-content: flex-start; align-items: flex-start; gap: 8px; display: inline-flex">
            <div style="color: white; font-size: 16px; font-family: Sarabun; font-weight: 700; line-height: 24px; word-wrap: break-word">Switch</div>
          </div>
              </div>
            </div>
        </a>
      </div>
        
        <!-- Static section with image and dynamic robot/path overlays -->
        <div style="width: 659px; height: 870px; left: 100px; top: 77px; position: absolute; box-shadow: 0px 6px 40px rgba(56.52, 119.95, 178.50, 0.08); border-radius: 24px; overflow: hidden;">
            <div style="width: 659px; height: 870px; position: absolute; background: #D9D9D9; border-radius: 24px"></div>
            <img id="canyonImage" style="width: 659px; height: 870px; position: absolute;" src="" />
            <canvas id="overlayCanvas" width="659" height="870" style="position: absolute; top: 0; left: 0;"></canvas>
            <!-- New legend overlay -->
            <div style="position: absolute; bottom: 10px; left: 10px; z-index: 10; background: rgba(255,255,255,0.8); padding: 5px; border-radius: 5px; font-size: 14px;">
                <div><span style="display:inline-block; width: 12px; height: 12px; background-color: red; margin-right: 5px;"></span>Operator</div>
                <div><span style="display:inline-block; width: 12px; height: 12px; background-color: blue; margin-right: 5px;"></span>Robot</div>
                <div><span style="display:inline-block; width: 12px; height: 12px; background-color: black; margin-right: 5px;"></span>Connector Path</div>
                <div><span style="display:inline-block; width: 12px; height: 12px; background-color: rgba(255, 0, 0, 0.1); margin-right: 5px;"></span>Overlay (Red)</div>
                <div><span style="display:inline-block; width: 12px; height: 12px; background-color: rgba(255, 255, 0, 0.1); margin-right: 5px;"></span>Overlay (Yellow)</div>
                <div><span style="display:inline-block; width: 12px; height: 12px; background-color: rgba(0, 255, 0, 0.1); margin-right: 5px;"></span>Overlay (Green)</div>
            </div>
        </div>

        <script>
            const canvas = document.getElementById('overlayCanvas');
            const ctx = canvas.getContext('2d');
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const gridCols = 20;
            const gridRows = 20;
            const cellWidth = canvasWidth / gridCols;
            const cellHeight = canvasHeight / gridRows;
            let gridMap = [];
            let robots = [];

            // Define operator marker at bottom center of the grid.
            const operator = {
              row: gridRows - 1,
              col: Math.floor(gridCols / 2),
              get x() { return (this.col + 0.5) * cellWidth; },
              get y() { return (this.row + 0.5) * cellHeight; }
            };

            // Create a grid map with open (true) or obstructed (false) cells.
            function generateMap() {
              gridMap = [];
              for (let r = 0; r < gridRows; r++) {
                let row = [];
                for (let c = 0; c < gridCols; c++) {
                  // 70% chance cell is open, 30% obstructed.  Reduced to 0.5 for more interesting paths
                  row.push(Math.random() < 0.5);
                }
                gridMap.push(row);
              }
            }

            // Function to calculate visibility of cells based on robot positions and operator trail
            function calculateVisibility() {
              const visibilityMap = Array.from({ length: gridRows }, () =>
                Array(gridCols).fill(false)
              );

              const visibilityRadius = 5; // Define the radius of visibility for each robot

              // Mark cells visible around each robot
              robots.forEach(robot => {
                for (let r = -visibilityRadius; r <= visibilityRadius; r++) {
                  for (let c = -visibilityRadius; c <= visibilityRadius; c++) {
                    const row = robot.row + r;
                    const col = robot.col + c;

                    // Check if the cell is within bounds and within the visibility radius
                    if (
                      row >= 0 &&
                      row < gridRows &&
                      col >= 0 &&
                      col < gridCols &&
                      Math.sqrt(r * r + c * c) <= visibilityRadius
                    ) {
                      visibilityMap[row][col] = true;
                    }
                  }
                }
              });

              // Mark cells visible along the operator's trail
              let current = { row: operator.row, col: operator.col };
              while (current.row >= 0) {
                visibilityMap[current.row][current.col] = true;
                current.row--; // Move upward to simulate the operator's trail
              }

              return visibilityMap;
            }

            // Draw the map overlay. Darken cells that are not visible.
            function drawMap() {
              const visibilityMap = calculateVisibility();

              for (let r = 0; r < gridRows; r++) {
                for (let c = 0; c < gridCols; c++) {
                  if (!visibilityMap[r][c]) {
                    ctx.fillStyle = 'rgba(0,0,0,0.3)'; // Darken non-visible cells
                    ctx.fillRect(c * cellWidth, r * cellHeight, cellWidth, cellHeight);
                  }
                }
              }
            }

            // Get all open cells from the grid.
            function getOpenCells() {
              const openCells = [];
              for (let r = 0; r < gridRows; r++) {
                for (let c = 0; c < gridCols; c++) {
                  if (gridMap[r][c]) {
                    openCells.push({ row: r, col: c });
                  }
                }
              }
              return openCells;
            }

            // New: Generate mission success percentages (sums ~100%)
            function generateSuccessPercentages() {
                let a = Math.random(), b = Math.random(), c = Math.random();
                const sum = a + b + c;
                return {
                    high: Math.round((a/sum)*100),
                    marginal: Math.round((b/sum)*100),
                    low: Math.round((c/sum)*100)
                };
            }

            // Updated: Place robots with a new "success" property
            function generateRobots(numRobots) {
                const openCells = getOpenCells();
                robots = [];
                for (let i = 0; i < numRobots && openCells.length; i++) {
                    const index = Math.floor(Math.random() * openCells.length);
                    const cell = openCells.splice(index, 1)[0];
                    const x = (cell.col + 0.5) * cellWidth;
                    const y = (cell.row + 0.5) * cellHeight;
                    robots.push({
                        x,
                        y,
                        row: cell.row,
                        col: cell.col,
                        success: generateSuccessPercentages() // New property with percentage scores
                    });
                }
            }

            // Draw robots as triangles.
            function drawRobots() {
              robots.forEach(robot => {
                ctx.beginPath();
                ctx.moveTo(robot.x, robot.y - 10);
                ctx.lineTo(robot.x + 10, robot.y + 10);
                ctx.lineTo(robot.x - 10, robot.y + 10);
                ctx.closePath();
                ctx.fillStyle = 'blue';
                ctx.fill();
              });
            }

            // Draw the operator marker as a red circle.
            function drawOperator() {
              ctx.beginPath();
              ctx.arc(operator.x, operator.y, 10, 0, 2 * Math.PI);
              ctx.fillStyle = 'red';
              ctx.fill();
            }

            // New: Overlay each cell with a random color (red, yellow, or green)
            function overlayRandomCells() {
                const colors = ['rgba(255, 0, 0, 0.1)', 'rgba(255, 255, 0, 0.1)', 'rgba(0, 255, 0, 0.1)'];
                for (let r = 0; r < gridRows; r++) {
                    for (let c = 0; c < gridCols; c++) {
                        const randomColor = colors[Math.floor(Math.random() * colors.length)];
                        ctx.fillStyle = randomColor;
                        ctx.fillRect(c * cellWidth, r * cellHeight, cellWidth, cellHeight);
                    }
                }
            }

            // Replace generatePath with one that uses boolean gridMap and continues even if visibility/traversability is not optimal:
            function generatePath(robot) {
              const path = [];
              let current = { row: operator.row, col: operator.col };
              const visited = new Set(); // Track visited cells to avoid overlap
              visited.add(`${current.row},${current.col}`); // Mark start as visited

              while (current.row !== robot.row || current.col !== robot.col) {
              // Determine possible moves (up, down, left, right)
              const possibleMoves = [];
              if (current.row < robot.row && current.row + 1 < gridRows) {
                possibleMoves.push({ row: current.row + 1, col: current.col }); //down
              }
              if (current.row > robot.row && current.row - 1 >= 0) {
                possibleMoves.push({ row: current.row - 1, col: current.col }); //up
              }
              if (current.col < robot.col && current.col + 1 < gridCols) {
                possibleMoves.push({ row: current.row, col: current.col + 1 }); //right
              }
              if (current.col > robot.col && current.col - 1 >= 0) {
                possibleMoves.push({ row: current.row, col: current.col - 1 }); //left
              }

              if (possibleMoves.length > 0) {
                // Choose move that minimizes Manhattan distance to robot and hasn't been visited
                let bestMove = null;
                let bestDistance = Infinity;

                for (let i = 0; i < possibleMoves.length; i++) {
                const move = possibleMoves[i];
                const cellKey = `${move.row},${move.col}`;
                if (!visited.has(cellKey)) {
                  let distance = Math.abs(move.row - robot.row) + Math.abs(move.col - robot.col);
                  if (distance < bestDistance) {
                  bestDistance = distance;
                  bestMove = move;
                  }
                }
                }

                if (bestMove) {
                current = bestMove;
                visited.add(`${current.row},${current.col}`); // Mark cell as visited
                } else {
                // If no unvisited move available, exit loop
                break;
                }
              } else {
                // If no move available, exit loop
                break;
              }
              path.push({ row: current.row, col: current.col });
              }
              return path;
            }

            // New: drawConnectorPath draws a black route from operator to each robot using generatePath
            function drawConnectorPath() {
                robots.forEach(robot => {
                    const path = generatePath(robot);
                    if (path.length > 0) {
                        ctx.beginPath();
                        ctx.moveTo(operator.x, operator.y);
                        path.forEach(cell => {
                            const x = (cell.col + 0.5) * cellWidth;
                            const y = (cell.row + 0.5) * cellHeight;
                            ctx.lineTo(x, y);
                        });
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    } else {
                        // Fallback to straight line if no path is computed
                        ctx.beginPath();
                        ctx.moveTo(operator.x, operator.y);
                        ctx.lineTo(robot.x, robot.y);
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                });
            }

            // Add a div to display robot attributes
            const robotAttributesDiv = document.createElement('div');
            robotAttributesDiv.id = 'robotAttributes';
            robotAttributesDiv.style.position = 'absolute';
            robotAttributesDiv.style.top = '77px'; // Adjust as needed
            robotAttributesDiv.style.left = '770px'; // Position to the right of the canvas
            robotAttributesDiv.style.width = '300px'; // Adjust as needed
            robotAttributesDiv.style.padding = '10px';
            robotAttributesDiv.style.background = 'rgba(255, 255, 255, 0.8)';
            robotAttributesDiv.style.border = '1px solid #ccc';
            robotAttributesDiv.style.borderRadius = '5px';
            canvas.parentElement.appendChild(robotAttributesDiv);

            // Create and style the tooltip (now appended to body)
            const tooltip = document.createElement('div');
            tooltip.id = 'robotTooltip';
            Object.assign(tooltip.style, {
                position: 'absolute',
                zIndex: '1000',
                background: 'rgba(255,255,255,0.95)',
                padding: '8px 12px',
                border: '1px solid #ccc',
                borderRadius: '6px',
                fontFamily: 'Sarabun, sans-serif',
                fontSize: '14px',
                boxShadow: '0 2px 10px rgba(0,0,0,0.2)',
                minWidth: '150px',
                pointerEvents: 'none',
                display: 'none',
                transition: 'opacity 0.2s ease'
            });
            document.body.appendChild(tooltip);

            // Add the missing scoring functions
            function calculateVisibilityScore(robot) {
            // Calculate maximum possible distance (from operator to farthest corner)
            const maxPossibleDistance = Math.sqrt(
                Math.pow(canvasWidth/2, 2) +  // Max horizontal distance
                Math.pow(canvasHeight, 2)     // Max vertical distance
            );
            
            // Calculate actual distance
            const actualDistance = Math.sqrt(
                Math.pow(robot.x - operator.x, 2) + 
                Math.pow(robot.y - operator.y, 2)
            );
            
            // Return normalized score between 0 and 1
            // Using exponential decay for more realistic visibility falloff
            return Math.exp(-actualDistance / (maxPossibleDistance * 0.5));
            }

            function calculateTraversabilityScore(robot) {
                // Calculate based on path quality (simplified example)
                const path = generatePath(robot);
                if (path.length === 0) return 0;
                
                let openCells = 0;
                path.forEach(cell => {
                    if (gridMap[cell.row][cell.col]) openCells++;
                });
                return openCells / path.length;
            }

            // Improved hover detection and positioning
            canvas.addEventListener('mousemove', function(evt) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = evt.clientX - rect.left;
                const mouseY = evt.clientY - rect.top;
                
                let closestRobot = null;
                let minDistance = Infinity;
                
                // Find closest robot to mouse pointer
                robots.forEach((robot, index) => {
                    const dx = mouseX - robot.x;
                    const dy = mouseY - robot.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 20 && distance < minDistance) {
                        minDistance = distance;
                        closestRobot = { robot, index };
                    }
                });
                
                if (closestRobot) {
                    const { robot, index } = closestRobot;
                    const visibility = calculateVisibilityScore(robot);
                    const traversability = calculateTraversabilityScore(robot);
                    
                    // Update tooltip content
                    tooltip.innerHTML = `
                        <div style="font-weight:700;margin-bottom:4px;">Robot ${index + 1}</div>
                        <div>Visibility: <span style="font-weight:600">${visibility.toFixed(2)}</span></div>
                        <div>Traversability: <span style="font-weight:600">${traversability.toFixed(2)}</span></div>
                    `;
                    
                    // Calculate position (default to right side)
                    let tooltipX = robot.x + 20;
                    let tooltipY = robot.y - tooltip.offsetHeight / 2;
                    
                    // Adjust for right edge
                    if (tooltipX + tooltip.offsetWidth > canvasWidth) {
                        tooltipX = robot.x - tooltip.offsetWidth - 20;
                    }
                    
                    // Adjust for bottom edge
                    if (tooltipY + tooltip.offsetHeight > canvasHeight) {
                        tooltipY = canvasHeight - tooltip.offsetHeight - 10;
                    }
                    
                    // Adjust for top edge
                    if (tooltipY < 10) {
                        tooltipY = 10;
                    }
                    
                    // Apply position with canvas offset
                    tooltip.style.left = `${rect.left + tooltipX}px`;
                    tooltip.style.top = `${rect.top + tooltipY}px`;
                    tooltip.style.display = 'block';
                } else {
                    tooltip.style.display = 'none';
                }
            });

            // Handle mouse leaving canvas
            canvas.addEventListener('mouseleave', function() {
                tooltip.style.display = 'none';
            });

            // Update redrawCanvas to display robot attributes
            function redrawCanvas() {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                const canyonImage = document.getElementById('canyonImage');
                ctx.drawImage(canyonImage, 0, 0, canvasWidth, canvasHeight);
                drawMap();
                overlayRandomCells(); // NEW random overlay across the grid
                drawConnectorPath(); // NEW: draw connector path along high visibility/traversability route
                drawOperator();
                drawRobots();

                // Display robot attributes
                let attributesHTML = '<h3>Robot Attributes</h3>';
                robots.forEach((robot, index) => {
                    const visibility = calculateVisibilityScore(robot);
                    const traversability = calculateTraversabilityScore(robot);
                    attributesHTML += `Robot ${index + 1}:<br>`;
                    attributesHTML += `vis${index + 1}: ${visibility.toFixed(2)}<br>`;
                    attributesHTML += `trav${index + 1}: ${traversability.toFixed(2)}<br><br>`;
                });
                robotAttributesDiv.innerHTML = attributesHTML;
            }

            let userResponses = []; // Initialize an array to store user responses
            let trialID = 1; // Initialize trial ID

            // Define visibility and traversability ratings based on mission success
            const missionSuccessRatings = {
                high: 1,
                marginal: 0.5,
                low: 0.1,
                compromised: 0.0
            };

            // Function to save userResponses to localStorage
            function saveResponses() {
                localStorage.setItem('userResponses', JSON.stringify(userResponses));
            }

            // Function to load userResponses from localStorage
            function loadResponses() {
                const storedResponses = localStorage.getItem('userResponses');
                if (storedResponses) {
                    userResponses = JSON.parse(storedResponses);
                } else {
                    userResponses = []; // Initialize if nothing is stored
                }
            }

            // Function to get the current count from localStorage
            function getCount() {
                let count = localStorage.getItem('count');
                return count ? parseInt(count) : 1; // Initialize to 1 if not found
            }

            // Function to set the count in localStorage
            function setCount(count) {
                localStorage.setItem('count', count);
                // Update the tracker display immediately
                document.getElementById('tracker').innerText = 'Tracker: ' + count + '/30';
            }

            // Initialize counter display
            let currentCount = getCount();
            document.getElementById('tracker').innerText = 'Tracker: ' + currentCount + '/30';
            
            // Increment the count after initialization
            currentCount += 1;
            setCount(currentCount);

            // Load responses on page load
            loadResponses();
            console.log("Loaded responses:", userResponses); // Debugging

            function recordResponse(choice, time, visibilities, traversabilities) {
                userResponses.push({
                    trialID: trialID++, // Increment trial ID for each response
                    choice: parseInt(choice.replace('robot', '')), // Convert choice to number
                    timeElapsed: time,
                    vis1: visibilities[0],
                    trav1: traversabilities[0],
                    vis2: visibilities[1],
                    trav2: traversabilities[1],
                    vis3: visibilities[2],
                    trav3: traversabilities[2]
                });
                console.log("Current responses:", userResponses); // Debugging
                saveResponses(); // Save after each response
            }

            // Add event listeners to the radio buttons
            const radioButtons = document.querySelectorAll('input[type="radio"][name="robot"]');
            radioButtons.forEach(radioButton => {
                radioButton.addEventListener('change', function() {
                    const startTime = performance.now(); // Record start time
                    const choice = this.value; // Store the chosen value

                    // Delay the recording of the response until after the user has had time to perceive the change
                    setTimeout(() => {
                        const endTime = performance.now(); // Record end time
                        const timeElapsed = endTime - startTime; // Calculate response time

                        // Calculate visibility and traversability scores for all robots
                        const visibilities = robots.map(robot => calculateVisibilityScore(robot));
                        const traversabilities = robots.map(robot => calculateTraversabilityScore(robot));

                        recordResponse(choice, timeElapsed, visibilities, traversabilities); // Record the response
                    }, 500); // Adjust the delay as needed
                });
            });

            // Function to convert responses to CSV format
            function convertToCSV(responses) {
                const header = "trialID\tchoice\tvis1\ttrav1\tvis2\ttrav2\tvis3\ttrav3\ttimeElapsed\n";
                let csv = header;
                responses.forEach(response => {
                    csv += `${response.trialID}\t${response.choice}\t${response.vis1}\t${response.trav1}\t${response.vis2}\t${response.trav2}\t${response.vis3}\t${response.trav3}\t${response.timeElapsed}\n`;
                });
                return csv;
            }

            // Function to download the data as a CSV file
            function downloadCSV(csv, filename) {
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename || 'user_responses.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }

            // Modify the "Next" button to conditionally download the CSV
            const nextButton = document.querySelector('.next-button');
            nextButton.addEventListener('click', function(event) {
                event.preventDefault(); // Prevent the default link behavior
                
                // First validate that a robot is selected
                const selectedRobot = document.querySelector('input[name="robot"]:checked');
                if (!selectedRobot) {
                    alert('Please select a robot path before continuing');
                    return;
                }
                
                // Get current count before incrementing
                let currentCount = getCount();
                console.log('Current count:', currentCount); // Debugging
                
                // Check if this is the last trial (10th)
                if (currentCount >= 30) {
                    if (userResponses.length > 0) {
                        console.log('Preparing to download responses...'); // Debugging
                        const csvData = convertToCSV(userResponses);
                        const now = new Date();
                        const dateString = now.toISOString().slice(0, 10);
                        const timeString = now.toTimeString().slice(0, 8).replace(/:/g, '');
                        const filename = `${dateString}-${timeString}-${trialID - 1}-Bounding_Overwatch.csv`;
                        
                        downloadCSV(csvData, filename);
                        localStorage.removeItem('userResponses');
                        userResponses = [];
                    }
                    
                    // Reset counter and redirect to home
                    setCount(1);
                    window.location.href = "BO_home_page.html";
                } else {
                    // Continue to next trial
                    window.location.href = "BO_mission_start.html";
                }
            });

            window.onload = function() {
                generateMap();
                generateRobots(3);
                redrawCanvas();
            };
        </script>
    </div>
</div>